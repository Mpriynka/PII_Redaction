<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Local PII Redactor</title>
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
    <script type="module">
        import { AutoTokenizer, env } from 'https://cdn.jsdelivr.net/npm/@huggingface/transformers';

        env.allowLocalModels = true;
        env.allowRemoteModels = false;
        env.localModelPath = 'models/';

        // Configuration
        const MODEL_FOLDER = "pii-model";

        // We will load these dynamically now!
        let ID2LABEL = null;
        let session = null;
        let tokenizer = null;

        async function loadModel() {
            const status = document.getElementById('status');
            status.innerText = "‚è≥ Loading model, tokenizer, and labels...";

            try {
                // 1. Load the Label Map (The Translation Dictionary)
                const response = await fetch(`./models/${MODEL_FOLDER}/labels.json`);
                if (!response.ok) throw new Error("Could not find labels.json!");
                const labelsConfig = await response.json();

                // Handle different JSON formats (sometimes keys are strings "0", sometimes ints)
                ID2LABEL = {};
                for (const [key, value] of Object.entries(labelsConfig)) {
                    ID2LABEL[parseInt(key)] = value;
                }
                console.log("‚úÖ Loaded Labels:", ID2LABEL);

                // 2. Load Tokenizer & Model
                tokenizer = await AutoTokenizer.from_pretrained(MODEL_FOLDER);
                session = await ort.InferenceSession.create(`./models/${MODEL_FOLDER}/model.onnx`, { executionProviders: ['wasm'] });

                status.innerText = "‚úÖ System Ready! (Loaded " + Object.keys(ID2LABEL).length + " labels)";
                document.getElementById('analyzeBtn').disabled = false;
            } catch (e) {
                status.innerText = "‚ùå Error: " + e.message;
                console.error(e);
            }
        }

        async function analyzeText() {
            const text = document.getElementById('inputText').value;
            if (!text) return;
            const outputDiv = document.getElementById('output');
            outputDiv.innerHTML = "Processing...";

            // 1. Tokenize
            const encoded = await tokenizer(text, {
                return_tensors: 'ort',
                padding: true,
                truncation: true,
                max_length: 512
            });

            // 2. Inference
            const feeds = {
                input_ids: encoded.input_ids,
                attention_mask: encoded.attention_mask
            };
            const results = await session.run(feeds);

            // 3. Process Results
            const logits = results.logits.data;
            const [batchSize, seqLen, numLabels] = results.logits.dims;
            const tokenIds = encoded.input_ids.data;

            // --- PASS 1: Collect all tokens with their labels ---
            const chunks = [];
            for (let i = 0; i < seqLen; i++) {
                // Find the best label (argmax)
                let maxScore = -Infinity;
                let predictedId = 0;

                for (let j = 0; j < numLabels; j++) {
                    const val = logits[i * numLabels + j];
                    if (val > maxScore) {
                        maxScore = val;
                        predictedId = j;
                    }
                }

                const label = ID2LABEL[predictedId] || "O";
                const tokenId = Number(tokenIds[i]);

                // Skip Special Tokens
                if (tokenId === 101 || tokenId === 102 || tokenId === 0) continue;

                let word = tokenizer.model.vocab[tokenId];
                if (!word) word = "";

                chunks.push({ word, label });
            }

            // --- PASS 2: Group Adjacent Entities (BIO Logic) ---
            let groups = [];
            let currentGroup = null;

            for (const chunk of chunks) {
                let { word, label } = chunk;

                // Handle subwords
                let isSubword = word.startsWith("##");
                if (isSubword) word = word.substring(2);

                let labelType = label === "O" ? "O" : label.substring(2); // Remove B- or I-
                let isStart = label.startsWith("B-");

                // Logic to continue previous group:
                // 1. We have a current group.
                // 2. The Types match.
                // 3. It is NOT a B- tag (unless it's a subword/continuation case, but strict BIO says B starts new).
                //    However, some weak models might output B- B- for "Rahul Mehta". 
                //    If we want to merge them, we can relax this.
                //    Let's strictly follow standard BIO for now: Only merge if I- follows B/I.

                let shouldMerge = false;

                if (currentGroup) {
                    if (currentGroup.type === labelType) {
                        if (labelType === "O") {
                            shouldMerge = true; // Always merge O's
                        } else if (!isStart) {
                            shouldMerge = true; // Merge I- into B- or I-
                        } else if (isSubword && isStart) {
                            // Weird case: Subword predicted as B-? Treat as merge usually.
                            shouldMerge = true;
                        }
                    }
                }

                if (shouldMerge) {
                    // Add space if it's a new word (and not punctuation)
                    if (!isSubword && !word.startsWith(".") && !word.startsWith(",")) {
                        currentGroup.text += " ";
                    }
                    currentGroup.text += word;
                } else {
                    // Push old group
                    if (currentGroup) groups.push(currentGroup);

                    // Start new group
                    currentGroup = {
                        type: labelType,
                        text: word,
                        isPii: labelType !== "O"
                    };
                }
            }
            if (currentGroup) groups.push(currentGroup);

            // --- PASS 3: Render HTML ---
            let newHtml = "";

            for (let i = 0; i < groups.length; i++) {
                const g = groups[i];

                // Add space between groups if implied
                // We only know we need a space if the *current* group text doesn't start with punctuation
                if (i > 0 && !g.text.startsWith(".") && !g.text.startsWith(",")) {
                    newHtml += " ";
                }

                if (g.isPii) {
                    let color = "#ffcccc";
                    if (g.type.includes("NAME")) color = "#ccffcc";
                    if (g.type.includes("EMAIL")) color = "#ccccff";

                    // Replace text with label
                    newHtml += `<span style="background-color: ${color}; padding: 2px 4px; border-radius: 4px; font-weight: bold;" title="${g.text}">[${g.type}]</span>`;
                } else {
                    newHtml += g.text;
                }
            }

            outputDiv.innerHTML = newHtml;
        }

        // Initialize
        loadModel();
        window.analyzeText = analyzeText;
    </script>
    <style>
        body {
            font-family: sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }

        textarea {
            width: 100%;
            height: 100px;
            margin-bottom: 1rem;
        }

        #output {
            padding: 1rem;
            border: 1px solid #ddd;
            background: #f9f9f9;
            min-height: 50px;
            line-height: 1.6;
        }

        .status {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 1rem;
        }
    </style>
</head>

<body>
    <h1>üîí Local Browser PII Redactor</h1>
    <div id="status" class="status">Initializing...</div>

    <textarea id="inputText" placeholder="Paste text here (e.g., My email is john@example.com)..."></textarea>
    <button id="analyzeBtn" onclick="analyzeText()" disabled>Redact PII</button>

    <h3>Output:</h3>
    <div id="output"></div>
</body>

</html>